# Лабораторная работа 2

### Описание
1. Невеста ищет себе жениха (существует единственное вакантное место).
2. Число претендентов - N.
3. Невеста общается с претендентами в случайном порядке, с каждым не более одного раза.
4. О каждом претенденте известно, лучше он или хуже любого из предыдущих.
5. Пообщавшись с претендентом, невеста сравнивает его с предыдущими и либо отказывает, либо принимает его предложение. Если предложение принято, они женятся и процесс останавливается. Если невеста отказывает жениху, то вернуться к нему позже она не сможет.
6. Невеста выигрывает, если она выберет самого лучшего претендента. Выбор даже второго по порядку сравнения — проигрыш.

### Задание
1. Разработать и обучить нейронную сеть, которая возьмет на себя роль невесты и будет решать принять предложение или отказать очередному жениху.
2. Сравнить результат принятия решения обученной нейронной сети и оптимальным математическим алгоритмом.


## Математический алгоритм
Математический алгоритм работает следующим образом:, отклоняется определённое количество кандидатов (примерно 1/e (где e ≈ 2.71828) от общего числа кандидатов) для того, чтобы оценить, каковы лучшие показатели в этой группе, а затем выбирается первый кандидат из оставшихся, который превосходит наилучшего из отклонённых. Это подход, который пытается сбалансировать риск пропуска лучших кандидатов и выбор слишком раннего кандидата.
![photo_2024-11-12_12-39-48](https://github.com/user-attachments/assets/c9ac0588-13f4-4758-a04d-c88df0497af6)

## Нейросеть
Для нейросетевого подхода был использован алгоритм обучения с подкреплением (reinforcement learning).

Принцип его работы таков: есть агент, который может сделать одно из двух действий - выбрать жениха или пропустить. За выбор правильного он получает награду, за выбор неправильного - штраф. В качестве среды используем случайно сгенерированную последовательность кандидатов и выбираем по очереди кандидатов оттуда. При обучении каждый раз перемешиваем последовательность кандидатов и перегенерируем их "хорошесть", чтобы алгоритм не выучил позиционные зависимости.

Был выбран алгоритм Q-learning. Его реализация была выполнена с помощью библиотеки gymnasium и ее официальной документации
![](https://github.com/mosikk/data_processing/blob/main/lab2/rl_solution_result.png)

### Выводы

Сравнивать алгоритмы будем по частоте выбора самого оптимального кандидата. У простого математического алгоритма точность немного выше, но в целом она на одном уровне с нейросетевым подходом. Это объясняется тем, что у данной задачи не так много закономерностей в данных, поэтому использование МЛ алгоритмов не сильно улучшает качество решения
